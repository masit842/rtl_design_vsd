# babySoC
BabySoC serves as an excellent entry point for understanding the fundamentals of System-on-Chip design because it captures the core architectural elements of a real SoC — such as the processor, memory, and interconnect — in a simplified and easy-to-analyze form. Its minimal design removes the complexity of industrial-scale systems, allowing learners to focus on how different components communicate, how data flows through the system, and how functional simulation verifies design intent. By experimenting with BabySoC, students gain hands-on experience with SoC concepts, Verilog-based modelling, and simulation workflows without getting overwhelmed by advanced protocols or large codebases.

# The role and value of functional modelling before RTL/physical design:
Functional modelling plays a crucial role in the early stages of SoC development by allowing designers to validate the system’s intended behavior before committing to low-level RTL implementation or physical design. It focuses on modelling the functionality of each component — such as the CPU, memory, and interconnect — at a high level, ensuring that data flow, control logic, and communication paths work correctly. This stage helps detect architectural flaws, verify performance expectations, and refine system specifications early, saving significant time and cost in later design phases. By using functional models, engineers can simulate and analyze the overall system behavior quickly, ensuring that the design meets its requirements before translating it into detailed RTL code and eventually fabricating the hardware.
Through this task, I gained a clear understanding of how different components of a System-on-Chip work together and how functional modelling helps verify the design before moving to the RTL and physical stages. I learned how tools like Icarus Verilog and GTKWave are used to simulate and visualize the internal behavior of a system, which gave me a more practical view of SoC functionality. BabySoC helped me understand the basic architecture without dealing with unnecessary complexity. As the next step, I plan to explore the RTL design phase of BabySoC in detail, understand signal-level interactions more deeply, and eventually move towards synthesizing and verifying the design on hardware.
